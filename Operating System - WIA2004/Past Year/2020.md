# Q1
![](../../images/Pasted%20image%2020250707002258.png)
 Question 1: Internal and External Fragmentation

**Internal Fragmentation** occurs when memory is allocated in fixed-size blocks or pages, and the allocated memory is slightly larger than what the process actually needs. The unused space within the allocated block is wasted and cannot be used by other processes. This typically happens with paging systems where memory is divided into equal-sized frames.

**How it occurs**: When a process requests memory, the system allocates a fixed-size block. If the process doesn't use the entire block, the remaining space becomes internal fragmentation.

**External Fragmentation** occurs when there is enough total free memory space to satisfy a memory request, but the available memory is not contiguous (broken into small pieces scattered throughout memory). This typically happens with variable-size memory allocation schemes like segmentation.

**How it occurs**: As processes are loaded and removed from memory, free memory blocks become scattered. Over time, small fragments of free memory appear between allocated blocks, making it impossible to allocate large contiguous blocks even when the total free memory is sufficient.

# Q2
![](../../images/Pasted%20image%2020250707002313.png)

 Question 2: Page Replacement Policies

 a) First-In First-Out (FIFO) Policy
Using 3 page frames for the reference string: W, X, W, Y, W, X, Z, X, W, X, Z

| Reference | Frame 1 | Frame 2 | Frame 3 | Page Fault      |
| --------- | ------- | ------- | ------- | --------------- |
| W         | W       | -       | -       | Yes             |
| X         | W       | X       | -       | Yes             |
| W         | W       | X       | -       | No              |
| Y         | W       | X       | Y       | Yes             |
| W         | W       | X       | Y       | No              |
| X         | W       | X       | Y       | No              |
| Z         | Z       | X       | Y       | Yes (replace W) |
| X         | Z       | X       | Y       | No              |
| W         | Z       | W       | Y       | Yes (replace X) |
| X         | Z       | W       | X       | Yes (replace Y) |
| Z         | Z       | W       | X       | No              |
```
W -> W,X -> W,X,Y -> Z,X,Y -> Z,W,Y -> Z,W,X
```

Total page faults: 6

 b) Least Recently Used (LRU) Policy

Using 3 page frames for the same reference string:

|Reference|Frame 1|Frame 2|Frame 3|Page Fault|
|---|---|---|---|---|
|W|W|-|-|Yes|
|X|W|X|-|Yes|
|W|W|X|-|No|
|Y|W|X|Y|Yes|
|W|W|X|Y|No|
|X|W|X|Y|No|
|Z|W|X|Z|Yes (replace Y)|
|X|W|X|Z|No|
|W|W|X|Z|No|
|X|W|X|Z|No|
|Z|W|X|Z|No|
Diagram : 
```
W -> W,X -> W,X,Y -> W,X,Z
```

Total page faults: 4


# Q3
![](../../images/Pasted%20image%2020250707002344.png)![](../../images/Pasted%20image%2020250707002356.png)
 Question 3: Scheduling Algorithms

a) Shortest Remaining Time (SRT)

Gantt Chart:
```
Time 0-1: Job 1 (completes at time 1)
Time 1-2: Job 2 starts (remaining time 4)
Time 2: Job 3 arrives (time needed 2 < Job 2's remaining 3) -> switch to Job 3
Time 2-4: Job 3 (completes at time 4)
Time 4: Job 4 arrives (time needed 1 < Job 2's remaining 3) -> switch to Job 4
Time 4-5: Job 4 (completes at time 5)
Time 5: Job 5 arrives (time needed 2 < Job 2's remaining 3) -> switch to Job 5
Time 5-7: Job 5 (completes at time 7)
Time 7-10: Job 2 (completes at time 10)
```

Turnaround times:

- Job 1: 1 - 0 = 1
- Job 2: 10 - 1 = 9
- Job 3: 4 - 2 = 2
- Job 4: 5 - 3 = 2
- Job 5: 7 - 4 = 3

Waiting times:

- Job 1: 0
- Job 2: (10-1) - 4 = 5
- Job 3: (4-2) - 2 = 0
- Job 4: (5-3) - 1 = 1
- Job 5: (7-4) - 2 = 1
    
Average turnaround time: (1+9+2+2+3)/5 = 17/5 = 3.4  
Average waiting time: (0+5+0+1+1)/5 = 7/5 = 1.4

 b) Round Robin (quantum = 2)

Gantt Chart:
```
Time 0-1: Job 1 (completes at time 1, only needed 1 cycle)
Time 1-3: Job 2 (runs for 2 cycles, remaining time 2)
Time 3-5: Job 3 (runs for 2 cycles, completes)
Time 5-7: Job 4 (runs for 1 cycle, completes at time 6)
Time 6-8: Job 5 (runs for 2 cycles, completes)
Time 8-10: Job 2 (remaining 2 cycles, runs to completion)
```

Turnaround times:

- Job 1: 1 - 0 = 1
- Job 2: 10 - 1 = 9
- Job 3: 5 - 2 = 3
- Job 4: 6 - 3 = 3    
- Job 5: 8 - 4 = 4
    
Waiting times:

- Job 1: 0
- Job 2: (10-1) - 4 = 5
- Job 3: (5-2) - 2 = 1
- Job 4: (6-3) - 1 = 2
- Job 5: (8-4) - 2 = 2
    
Average turnaround time: (1+9+3+3+4)/5 = 20/5 = 4  
Average waiting time: (0+5+1+2+2)/5 = 10/5 = 2
# Q4
![](../../images/Pasted%20image%2020250707002415.png)

 Question 4: Deadlock

**Deadlock** is a situation in a multi-process system where two or more processes are unable to proceed because each is waiting for the other to release a resource. Deadlock occurs when four conditions hold simultaneously:

1. Mutual exclusion: Resources cannot be shared
2. Hold and wait: Processes hold resources while waiting for others
3. No preemption: Resources cannot be forcibly taken from processes
4. Circular wait: A circular chain of processes exists where each waits for a resource held by the next
    

**Directed Graph**:
- Resources: R1, R2, R3, R4
- Processes: P1, P2, P3, P4
    
Graph edges based on the table:

1. P1 → R1 (P1 holds R1)
2. P2 → R2 (P2 holds R2)
3. P3 → R3 (P3 holds R3)
4. P4 → R4 (P4 holds R4)
5. P1 → R2 (P1 requests R2)
6. P2 → R1 (P2 requests R1)
7. P3 → R2 and R4 (P3 requests R2 and R4)
8. P4 → R3 (P4 requests R3)
    
This creates a circular wait:

- P1 holds R1 and waits for R2 (held by P2)
- P2 holds R2 and waits for R1 (held by P1)  
    This is a deadlock between P1 and P2.
    

Additionally:

- P3 holds R3 and waits for R4 (held by P4)
- P4 holds R4 and waits for R3 (held by P3)  
    This is another deadlock between P3 and P4.
    

**Deadlock Resolution**:

1. **Prevention**: Break one of the four necessary conditions
    - For P1-P2 deadlock: Allow resource preemption (take R1 from P1 or R2 from P2)
    - For P3-P4 deadlock: Require processes to request all resources at once
        
2. **Avoidance**: Use Banker's algorithm to ensure safe state
    
3. **Detection and Recovery**:
    
    - Detect the cycles in the resource allocation graph
        
    - Select a victim process to terminate (e.g., P1 or P2 for first deadlock, P3 or P4 for second)
        
    - Rollback the victim process to release its resources
# Q5
![](../../images/Pasted%20image%2020250707002429.png)

 Question 5: Access Control Matrix Conversion

 i) Access Control List (ACL)

For each file, list which users have what permissions:

**File 1**:

- User 1: RWED
    
- User 2: R-E-
    
- User 4: RWE-
    
- User 5: -E-
    

**File 2**:

- User 2: R-E-
    
- User 3: R-E-
    
- User 4: -E-
    

**File 3**:

- User 2: RWED
    
- User 4: -E-
    

**File 4**:

- User 1: R-E-
    
- User 5: RWED
    

**File 5**:

- User 5: RWED
    

### ii) Capability List

For each user, list what files they can access and with what permissions:

**User 1**:

- File 1: RWED
    
- File 4: R-E-
    

**User 2**:

- File 1: R-E-
    
- File 2: R-E-
    
- File 3: RWED
    

**User 3**:

- File 2: R-E-
    

**User 4**:

- File 1: RWE-
    
- File 2: -E-
    
- File 3: -E-
    

**User 5**:

- File 1: -E-
    
- File 4: RWED
    
- File 5: RWED
    

The capability list represents the same information as the access control matrix but organized by user rather than by file. Each user's capabilities show exactly what files they can access and what operations they can perform on each file.