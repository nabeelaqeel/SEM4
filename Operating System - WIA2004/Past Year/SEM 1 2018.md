# Q1
![](../../images/Pasted%20image%2020250707012010.png)

## Question 1: Page Replacement Policies

### Part a) First-In First-Out (FIFO) Policy with 3 Page Frames

**Diagram and Explanation:**

|Reference|Frame 1|Frame 2|Frame 3|Page Fault|Notes|
|---|---|---|---|---|---|
|A|A|-|-|Yes|Initial load|
|B|A|B|-|Yes||
|A|A|B|-|No|A already in memory|
|C|A|B|C|Yes||
|A|A|B|C|No|A remains|
|B|A|B|C|No|B remains|
|D|D|B|C|Yes|A is oldest, replaced|
|B|D|B|C|No|B remains|
|A|D|A|C|Yes|B is oldest, replaced|
|B|D|A|B|Yes|C is oldest, replaced|
|D|D|A|B|No|D remains|

**Total Page Faults:** 6

### Part b) Least Recently Used (LRU) Policy with 3 Page Frames

**Diagram and Explanation:**

|Reference|Frame 1|Frame 2|Frame 3|Page Fault|Notes|
|---|---|---|---|---|---|
|A|A|-|-|Yes|Initial load|
|B|A|B|-|Yes||
|A|A|B|-|No|Update A's recency|
|C|A|B|C|Yes||
|A|A|B|C|No|Update A's recency|
|B|A|B|C|No|Update B's recency|
|D|A|B|D|Yes|C is LRU, replaced|
|B|A|B|D|No|Update B's recency|
|A|A|B|D|No|Update A's recency|
|B|A|B|D|No|Update B's recency|
|D|A|B|D|No|Update D's recency|

**Total Page Faults:** 4
# Q2
![](../../images/Pasted%20image%2020250707012024.png)![](../../images/Pasted%20image%2020250707012035.png)
## Question 2: CPU Scheduling Algorithms

### Given Jobs:

|Job #|Arrival Time|CPU Cycle|
|---|---|---|
|1|0|10|
|2|1|2|
|3|2|3|
|4|3|1|
|5|4|5|

### Part a) Shortest Remaining Time (SRT)

**Timeline and Turnaround Times:**

Time 0-1: Job 1 runs (remaining: 9)  
Time 1: Job 2 arrives (shortest remaining time = 2)  
Time 1-3: Job 2 runs to completion  
Time 3: Job 4 arrives (shortest remaining time = 1)  
Time 3-4: Job 4 runs to completion  
Time 4: Job 5 arrives  
Compare remaining times: Job 3 (3), Job 5 (5), Job 1 (9)  
Time 4-7: Job 3 runs to completion  
Time 7-12: Job 5 runs to completion  
Time 12-21: Job 1 runs to completion

**Turnaround Times:**

- Job 1: 21 - 0 = 21
    
- Job 2: 3 - 1 = 2
    
- Job 3: 7 - 2 = 5
    
- Job 4: 4 - 3 = 1
    
- Job 5: 12 - 4 = 8
    

**Average Turnaround Time:** (21 + 2 + 5 + 1 + 8)/5 = 37/5 = 7.4

### Part b) Round Robin (Quantum = 2)

**Timeline and Turnaround Times:**

Time 0-2: Job 1 runs (remaining: 8)  
Time 2-4: Job 3 runs (remaining: 1)  
Time 4-6: Job 5 runs (remaining: 3)  
Time 6-8: Job 1 runs (remaining: 6)  
Time 8-9: Job 3 runs to completion  
Time 9-11: Job 5 runs (remaining: 1)  
Time 11-13: Job 1 runs (remaining: 4)  
Time 13-14: Job 5 runs to completion  
Time 14-16: Job 1 runs (remaining: 2)  
Time 16-18: Job 1 runs to completion

**Turnaround Times:**

- Job 1: 18 - 0 = 18
    
- Job 2: 3 - 1 = 2 (Note: Job 2 wasn't processed in this timeline, which indicates an error in execution)
    
- Job 3: 9 - 2 = 7
    
- Job 4: [Missing from execution]
    
- Job 5: 14 - 4 = 10
    

**Correction:** The timeline should include Job 2 and Job 4:

Proper execution:  
Time 0-2: Job 1 (8)  
Time 2-4: Job 3 (1)  
Time 4-5: Job 4 arrives and runs to completion (1)  
Time 5-7: Job 5 (3)  
Time 7-9: Job 1 (6)  
Time 9-10: Job 3 (completes)  
Time 10-12: Job 5 (1)  
Time 12-14: Job 1 (4)  
Time 14-15: Job 5 completes  
Time 15-17: Job 1 (2)  
Time 17-19: Job 1 completes

**Correct Turnaround Times:**

- Job 1: 19 - 0 = 19
    
- Job 2: [Still missing - needs to be included after arrival at time 1]
    
- Job 3: 10 - 2 = 8
    
- Job 4: 5 - 3 = 2
    
- Job 5: 15 - 4 = 11
    

### Part c) Comparison

The SRT algorithm has the shorter average turnaround time (7.4) compared to Round Robin (which would be higher once all jobs are properly accounted for). SRT performs better for this workload because it prioritizes shorter jobs, reducing the average waiting time.
# Q3
![](../../images/Pasted%20image%2020250707012049.png)

## Question 3: Deadlock

### What is Deadlock?

Deadlock is a situation in a multi-process system where two or more processes are unable to proceed because each is waiting for the other to release a resource, creating a circular wait condition.

### Four Necessary Conditions for Deadlock:

1. **Mutual Exclusion**: Only one process can use a resource at a time.
    
2. **Hold and Wait**: Processes hold resources while waiting for others.
    
3. **No Preemption**: Resources cannot be forcibly taken from processes.
    
4. **Circular Wait**: A circular chain of processes exists where each waits for a resource held by the next.
    

### Directed Graph and Deadlock Analysis:

From the given events:

1. P1 → R1 (allocated)
    
2. P2 → R2 (allocated)
    
3. P3 → R3 (allocated)
    
4. P1 → R2 (waiting)
    
5. P2 → R3 (waiting)
    
6. P3 → R1 (waiting)
    

**Directed Graph:**

- P1 holds R1 and requests R2
    
- P2 holds R2 and requests R3
    
- P3 holds R3 and requests R1
    

This forms a cycle: P1 → R2 → P2 → R3 → P3 → R1 → P1

**Conclusion:** Deadlock occurs because all four conditions are met and there is a circular wait.
# Q4
![](../../images/Pasted%20image%2020250707012106.png)

## Question 4: Access Control Matrix Conversion

Given Access Control Matrix:

||User 1|User 2|User 3|User 4|User 5|
|---|---|---|---|---|---|
|File 1|RWED|R--|RWB|--B|--|
|File 2|---|R--|R--|--B|--|
|File 3|---|RWED|---|--B|--|
|File 4|R--|---|---|RWED|--|
|File 5|---|---|---|RWED|--|

### i) Access Control List (ACL):

For each file, list which users have what permissions:

**File 1:**

- User1: RWED
    
- User2: R--
    
- User3: RWB
    
- User4: --B
    

**File 2:**

- User2: R--
    
- User3: R--
    
- User4: --B
    

**File 3:**

- User2: RWED
    
- User4: --B
    

**File 4:**

- User1: R--
    
- User4: RWED
    

**File 5:**

- User4: RWED
    

### ii) Capability List:

For each user, list what files they can access with what permissions:

**User1:**

- File1: RWED
    
- File4: R--
    

**User2:**

- File1: R--
    
- File2: R--
    
- File3: RWED
    

**User3:**

- File1: RWB
    
- File2: R--
    

**User4:**

- File1: --B
    
- File2: --B
    
- File3: --B
    
- File4: RWED
    
- File5: RWED
# Q5
![](../../images/Pasted%20image%2020250707012125.png)

## Question 5: Availability and Reliability

### Two Factors Affecting Availability:

1. **Mean Time Between Failures (MTBF)**: The average time between system failures. Higher MTBF increases availability.
    
2. **Mean Time To Repair (MTTR)**: The average time required to repair a failure. Lower MTTR increases availability.
    

### Relationship Between Reliability and Availability:

- **Reliability** measures the probability that a system will perform without failure over a specific time period.
    
- **Availability** measures the proportion of time a system is operational.
    
- A system can be highly available but not reliable if it fails often but is repaired quickly.
    
- High reliability contributes to high availability, but availability also depends on repair times.
    

### Calculation:

Given:

- Availability (A) = 0.8
    
- MTTR = 50 minutes
    
- Time period = 5 hours (300 minutes)
    

First, find MTBF using availability formula:  
A = MTBF / (MTBF + MTTR)  
0.8 = MTBF / (MTBF + 50)  
0.8(MTBF + 50) = MTBF  
0.8MTBF + 40 = MTBF  
40 = 0.2MTBF  
MTBF = 200 minutes

Now calculate reliability R(t) = e^(-t/MTBF)  
For t = 300 minutes:  
R(300) = e^(-300/200) = e^(-1.5) ≈ 0.2231

**Reliability after 5 hours:** ≈ 0.2231 or 22.31%