# Q1
![](../../images/Pasted%20image%2020250707001747.png)

## Question 1

### a) Fixed Partitioning vs Dynamic Partitioning (8 marks)

**Fixed Partitioning:**

- Memory is divided into fixed-size partitions at system startup
    
- Each partition can hold exactly one process
    
- Partition sizes may be equal or unequal
    
- OS maintains a queue for each partition
    

_Strengths:_

- Simple to implement
    
- Low overhead as partition sizes are predetermined
    
- Fast allocation/deallocation
    

_Weaknesses:_

- Internal fragmentation (unused memory within partitions)
    
- Limits process size to partition size
    
- Inflexible for varying memory needs
    

**Dynamic Partitioning:**

- Memory is divided as needed when processes arrive
    
- Partition sizes exactly match process requirements
    
- Uses variable-size partitions
    

_Strengths:_

- No internal fragmentation
    
- More efficient memory utilization
    
- Can accommodate larger processes
    

_Weaknesses:_

- External fragmentation (small unusable memory blocks between partitions)
    
- More complex allocation algorithms needed
    
- Slower allocation due to search for suitable space

### b) Technique to Overcome External Fragmentation (4 marks)

**Compaction** is a technique used to overcome external fragmentation:

- Periodically moves all occupied memory blocks to one end
    
- Combines all free memory into one large contiguous block
    
- Requires all programs to be relocatable (can execute from different memory addresses)
    

_Difficulties:_

- High CPU overhead during compaction
    
- May require significant time for large memories
    
- Must suspend all processes during compaction
    

_Prerequisites:_

- Dynamic relocation capability (base/limit registers)
    
- Support for address translation during execution
    
- All pointers must be relative, not absolute

# Q2
![](../../images/Pasted%20image%2020250707001802.png)
![](../../images/Pasted%20image%2020250707001819.png)
### a) Four Scheduling Criteria (4 marks)

1. **CPU Utilization**: Percentage of time CPU is busy (should be maximized)
    
2. **Throughput**: Number of processes completed per time unit (should be maximized)
    
3. **Turnaround Time**: Time from process submission to completion (should be minimized)
    
4. **Waiting Time**: Total time process spends waiting in ready queue (should be minimized)
    
5. **Response Time**: Time from request submission to first response (important for interactive systems)
    

### b) FCFS vs Round Robin Comparison (4 marks)

**First-Come-First-Served (FCFS):**

- Non-preemptive scheduling
    
- Processes executed in order of arrival
    
- Simple to implement
    
- Can lead to convoy effect (long processes delay short ones)
    
- Poor for short processes if long ones arrive first
    

**Round Robin:**

- Preemptive scheduling using time slices
    
- Each process gets equal CPU time (quantum)
    
- If process doesn't complete in quantum, it's moved to end of queue
    
- Better for short processes
    
- Good response time for interactive systems
    
- Performance depends heavily on quantum size
    

### c) Effect of Time Quantum Size (4 marks)

- **Large quantum**: Approaches FCFS behavior, may hurt response time for short processes
    
- **Small quantum**: Better response time but higher context switch overhead
    
- **Optimal quantum**: Typically between 10-100ms
    
    - Large enough that context switch overhead is small fraction
        
    - Small enough to provide good interactive response
        
- Too small: Excessive context switching reduces CPU utilization
    
- Too large: Degrades to FCFS behavior with poor response time
    

### d) Scheduling Examples (6 marks)

**FCFS Schedule:**  
0-6: P1 (arrives at 0, runs for 6)  
6-16: P2 (arrives at 2, runs for 10)  
16-20: P3 (arrives at 6, runs for 4)  
20-22: P4 (arrives at 12, runs for 2)  
22-30: P5 (arrives at 16, runs for 8)

Turnaround times:  
P1: 6-0 = 6ms  
P2: 16-2 = 14ms  
P3: 20-6 = 14ms  
P4: 22-12 = 10ms  
P5: 30-16 = 14ms

**Round Robin Schedule (quantum=4ms):**  
0-4: P1 (4ms done, 2ms remaining)  
4-8: P2 (arrived at 2, runs 4ms, 6ms remaining)  
8-10: P1 (runs remaining 2ms, completes at 10)  
10-14: P2 (runs 4ms, 2ms remaining)  
14-16: P3 (arrived at 6, runs 2ms, completes)  
16-18: P2 (runs remaining 2ms, completes at 18)  
18-20: P4 (arrived at 12, runs 2ms, completes at 20)  
20-24: P5 (arrived at 16, runs 4ms, 4ms remaining)  
24-28: P5 (runs 4ms, completes at 28)

Turnaround times:  
P1: 10-0 = 10ms  
P2: 18-2 = 16ms  
P3: 16-6 = 10ms  
P4: 20-12 = 8ms  
P5: 28-16 = 12ms
# Q3
![](../../images/Pasted%20image%2020250707001833.png)
![](../../images/Pasted%20image%2020250707001849.png)
![](../../images/Pasted%20image%2020250707001909.png)

### a) Available Vector Calculation (2 marks)

Total Resources: R1=15, R2=6, R3=9, R4=10

Allocated Resources:  
R1: 2+0+4+1+1+1 = 9  
R2: 0+1+1+0+1+0 = 3  
R3: 2+1+0+0+0+1 = 4  
R4: 1+1+2+1+0+1 = 6

Available = Total - Allocated  
R1: 15-9 = 6  
R2: 6-3 = 3  
R3: 9-4 = 5  
R4: 10-6 = 4

Available Vector = (6, 3, 5, 4)

### b) Need Matrix Calculation (2 marks)

Need = Claim - Allocation

|Process|R1|R2|R3|R4|
|---|---|---|---|---|
|P0|9-2=7|5-0=5|5-2=3|5-1=4|
|P1|2-0=2|2-1=1|3-1=2|3-1=2|
|P2|7-4=3|5-1=4|4-0=4|4-2=2|
|P3|3-1=2|3-0=3|3-0=3|2-1=1|
|P4|5-1=4|2-1=1|2-0=2|1-0=1|
|P5|4-1=3|4-0=4|4-1=3|4-1=3|

### c) Safety Check (5 marks)

Given sequence: P3 → P4 → P5 → P2 → P1 → P0

Initial Available: (6,3,5,4)

1. P3: Need (2,3,3,1) ≤ Available (6,3,5,4) → Execute  
    Release P3's allocation (1,0,0,1)  
    New Available: (6+1,3+0,5+0,4+1) = (7,3,5,5)
    
2. P4: Need (4,1,2,1) ≤ Available (7,3,5,5) → Execute  
    Release P4's allocation (1,1,0,0)  
    New Available: (7+1,3+1,5+0,5+0) = (8,4,5,5)
    
3. P5: Need (3,4,3,3) ≤ Available (8,4,5,5) → Execute  
    Release P5's allocation (1,0,1,1)  
    New Available: (8+1,4+0,5+1,5+1) = (9,4,6,6)
    
4. P2: Need (3,4,4,2) ≤ Available (9,4,6,6) → Execute  
    Release P2's allocation (4,1,0,2)  
    New Available: (9+4,4+1,6+0,6+2) = (13,5,6,8)
    
5. P1: Need (2,1,2,2) ≤ Available (13,5,6,8) → Execute  
    Release P1's allocation (0,1,1,1)  
    New Available: (13+0,5+1,6+1,8+1) = (13,6,7,9)
    
6. P0: Need (7,5,3,4) ≤ Available (13,6,7,9) → Execute
    

Since all processes can complete, the system is in a safe state.

### d) P5 Request Evaluation (6 marks)

Request from P5: (3,2,3,3)

1. Check if request ≤ Need for P5:  
    P5 Need: (3,4,3,3)  
    Request (3,2,3,3) ≤ Need → Valid
    
2. Check if request ≤ Available:  
    Available: (6,3,5,4)  
    Request (3,2,3,3) ≤ Available → Can be granted provisionally
    
3. Pretend to allocate:  
    New Allocation for P5: (1+3,0+2,1+3,1+3) = (4,2,4,4)  
    New Available: (6-3,3-2,5-3,4-3) = (3,1,2,1)  
    New Need for P5: (3-3,4-2,3-3,3-3) = (0,2,0,0)
    
4. Check if system would still be safe:  
    Find a process whose Need ≤ Available (3,1,2,1)
    
    - P0: (7,5,3,4) > (3,1,2,1) → No
        
    - P1: (2,1,2,2) > (3,1,2,1) → No (R4 insufficient)
        
    - P2: (3,4,4,2) > (3,1,2,1) → No
        
    - P3: (2,3,3,1) > (3,1,2,1) → No
        
    - P4: (4,1,2,1) > (3,1,2,1) → No (R1 insufficient)
        
    - P5: (0,2,0,0) ≤ (3,1,2,1) → No (R2 insufficient)
        

No process can run with current Available, so granting this request would lead to an unsafe state. Therefore, the request should be denied and P5 must wait.


# Q4
![](../../images/Pasted%20image%2020250707012821.png)