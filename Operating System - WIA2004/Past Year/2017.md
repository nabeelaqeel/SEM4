# Q1
![](../../images/Pasted%20image%2020250707001747.png)

## Question 1

### a) Fixed Partitioning vs Dynamic Partitioning (8 marks)

**Fixed Partitioning:**

- Memory is divided into fixed-size partitions at system startup
    
- Each partition can hold exactly one process
    
- Partition sizes may be equal or unequal
    
- OS maintains a queue for each partition
    

_Strengths:_

- Simple to implement
    
- Low overhead as partition sizes are predetermined
    
- Fast allocation/deallocation
    

_Weaknesses:_

- Internal fragmentation (unused memory within partitions)
    
- Limits process size to partition size
    
- Inflexible for varying memory needs
    

**Dynamic Partitioning:**

- Memory is divided as needed when processes arrive
    
- Partition sizes exactly match process requirements
    
- Uses variable-size partitions
    

_Strengths:_

- No internal fragmentation
    
- More efficient memory utilization
    
- Can accommodate larger processes
    

_Weaknesses:_

- External fragmentation (small unusable memory blocks between partitions)
    
- More complex allocation algorithms needed
    
- Slower allocation due to search for suitable space

### b) Technique to Overcome External Fragmentation (4 marks)

**Compaction** is a technique used to overcome external fragmentation:

- Periodically moves all occupied memory blocks to one end
    
- Combines all free memory into one large contiguous block
    
- Requires all programs to be relocatable (can execute from different memory addresses)
    

_Difficulties:_

- High CPU overhead during compaction
    
- May require significant time for large memories
    
- Must suspend all processes during compaction
    

_Prerequisites:_

- Dynamic relocation capability (base/limit registers)
    
- Support for address translation during execution
    
- All pointers must be relative, not absolute

# Q2
![](../../images/Pasted%20image%2020250707001802.png)
![](../../images/Pasted%20image%2020250707001819.png)
### a) Four Scheduling Criteria (4 marks)

1. **CPU Utilization**: Percentage of time CPU is busy (should be maximized)
    
2. **Throughput**: Number of processes completed per time unit (should be maximized)
    
3. **Turnaround Time**: Time from process submission to completion (should be minimized)
    
4. **Waiting Time**: Total time process spends waiting in ready queue (should be minimized)
    
5. **Response Time**: Time from request submission to first response (important for interactive systems)
    

### b) FCFS vs Round Robin Comparison (4 marks)

**First-Come-First-Served (FCFS):**

- Non-preemptive scheduling
    
- Processes executed in order of arrival
    
- Simple to implement
    
- Can lead to convoy effect (long processes delay short ones)
    
- Poor for short processes if long ones arrive first
    

**Round Robin:**

- Preemptive scheduling using time slices
    
- Each process gets equal CPU time (quantum)
    
- If process doesn't complete in quantum, it's moved to end of queue
    
- Better for short processes
    
- Good response time for interactive systems
    
- Performance depends heavily on quantum size
    

### c) Effect of Time Quantum Size (4 marks)

- **Large quantum**: Approaches FCFS behavior, may hurt response time for short processes
    
- **Small quantum**: Better response time but higher context switch overhead
    
- **Optimal quantum**: Typically between 10-100ms
    
    - Large enough that context switch overhead is small fraction
        
    - Small enough to provide good interactive response
        
- Too small: Excessive context switching reduces CPU utilization
    
- Too large: Degrades to FCFS behavior with poor response time
    

### d) Scheduling Examples (6 marks)

**FCFS Schedule:**  
0-6: P1 (arrives at 0, runs for 6)  
6-16: P2 (arrives at 2, runs for 10)  
16-20: P3 (arrives at 6, runs for 4)  
20-22: P4 (arrives at 12, runs for 2)  
22-30: P5 (arrives at 16, runs for 8)

Turnaround times:  
P1: 6-0 = 6ms  
P2: 16-2 = 14ms  
P3: 20-6 = 14ms  
P4: 22-12 = 10ms  
P5: 30-16 = 14ms

**Round Robin Schedule (quantum=4ms):**  
0-4: P1 (4ms done, 2ms remaining)  
4-8: P2 (arrived at 2, runs 4ms, 6ms remaining)  
8-10: P1 (runs remaining 2ms, completes at 10)  
10-14: P2 (runs 4ms, 2ms remaining)  
14-16: P3 (arrived at 6, runs 2ms, completes)  
16-18: P2 (runs remaining 2ms, completes at 18)  
18-20: P4 (arrived at 12, runs 2ms, completes at 20)  
20-24: P5 (arrived at 16, runs 4ms, 4ms remaining)  
24-28: P5 (runs 4ms, completes at 28)

Turnaround times:  
P1: 10-0 = 10ms  
P2: 18-2 = 16ms  
P3: 16-6 = 10ms  
P4: 20-12 = 8ms  
P5: 28-16 = 12ms
# Q3
![](../../images/Pasted%20image%2020250707001833.png)
![](../../images/Pasted%20image%2020250707001849.png)
![](../../images/Pasted%20image%2020250707001909.png)

### a) Available Vector Calculation (2 marks)

Total Resources: R1=15, R2=6, R3=9, R4=10

Allocated Resources:  
R1: 2+0+4+1+1+1 = 9  
R2: 0+1+1+0+1+0 = 3  
R3: 2+1+0+0+0+1 = 4  
R4: 1+1+2+1+0+1 = 6

Available = Total - Allocated  
R1: 15-9 = 6  
R2: 6-3 = 3  
R3: 9-4 = 5  
R4: 10-6 = 4

Available Vector = (6, 3, 5, 4)

### b) Need Matrix Calculation (2 marks)

Need = Claim - Allocation

|Process|R1|R2|R3|R4|
|---|---|---|---|---|
|P0|9-2=7|5-0=5|5-2=3|5-1=4|
|P1|2-0=2|2-1=1|3-1=2|3-1=2|
|P2|7-4=3|5-1=4|4-0=4|4-2=2|
|P3|3-1=2|3-0=3|3-0=3|2-1=1|
|P4|5-1=4|2-1=1|2-0=2|1-0=1|
|P5|4-1=3|4-0=4|4-1=3|4-1=3|

### c) Safety Check (5 marks)

Given sequence: P3 → P4 → P5 → P2 → P1 → P0

Initial Available: (6,3,5,4)

1. P3: Need (2,3,3,1) ≤ Available (6,3,5,4) → Execute  
    Release P3's allocation (1,0,0,1)  
    New Available: (6+1,3+0,5+0,4+1) = (7,3,5,5)
    
2. P4: Need (4,1,2,1) ≤ Available (7,3,5,5) → Execute  
    Release P4's allocation (1,1,0,0)  
    New Available: (7+1,3+1,5+0,5+0) = (8,4,5,5)
    
3. P5: Need (3,4,3,3) ≤ Available (8,4,5,5) → Execute  
    Release P5's allocation (1,0,1,1)  
    New Available: (8+1,4+0,5+1,5+1) = (9,4,6,6)
    
4. P2: Need (3,4,4,2) ≤ Available (9,4,6,6) → Execute  
    Release P2's allocation (4,1,0,2)  
    New Available: (9+4,4+1,6+0,6+2) = (13,5,6,8)
    
5. P1: Need (2,1,2,2) ≤ Available (13,5,6,8) → Execute  
    Release P1's allocation (0,1,1,1)  
    New Available: (13+0,5+1,6+1,8+1) = (13,6,7,9)
    
6. P0: Need (7,5,3,4) ≤ Available (13,6,7,9) → Execute
    

Since all processes can complete, the system is in a safe state.

### d) P5 Request Evaluation (6 marks)

Request from P5: (3,2,3,3)

1. Check if request ≤ Need for P5:  
    P5 Need: (3,4,3,3)  
    Request (3,2,3,3) ≤ Need → Valid
    
2. Check if request ≤ Available:  
    Available: (6,3,5,4)  
    Request (3,2,3,3) ≤ Available → Can be granted provisionally
    
3. Pretend to allocate:  
    New Allocation for P5: (1+3,0+2,1+3,1+3) = (4,2,4,4)  
    New Available: (6-3,3-2,5-3,4-3) = (3,1,2,1)  
    New Need for P5: (3-3,4-2,3-3,3-3) = (0,2,0,0)
    
4. Check if system would still be safe:  
    Find a process whose Need ≤ Available (3,1,2,1)
    
    - P0: (7,5,3,4) > (3,1,2,1) → No
        
    - P1: (2,1,2,2) > (3,1,2,1) → No (R4 insufficient)
        
    - P2: (3,4,4,2) > (3,1,2,1) → No
        
    - P3: (2,3,3,1) > (3,1,2,1) → No
        
    - P4: (4,1,2,1) > (3,1,2,1) → No (R1 insufficient)
        
    - P5: (0,2,0,0) ≤ (3,1,2,1) → No (R2 insufficient)
        

No process can run with current Available, so granting this request would lead to an unsafe state. Therefore, the request should be denied and P5 must wait.


# Q4
![](../../images/Pasted%20image%2020250707012821.png)

### Characteristics of Embedded Operating System (OS)

An Embedded Operating System (OS) is a specialized OS designed to perform specific tasks within embedded systems, which are dedicated computing devices with limited resources. Here are the key characteristics of an Embedded OS:

1. **Real-Time Operation**: Many embedded OSs are real-time operating systems (RTOS), meaning they must process and respond to inputs within a strict time frame to ensure timely and predictable performance. This is critical in applications like medical devices, automotive systems, and industrial automation.
    
2. **Resource Efficiency**: Embedded OSs are optimized to run on hardware with limited resources, such as minimal memory (RAM and ROM), low processing power, and limited storage. They are designed to be lightweight and efficient.
    
3. **Task-Specific Functionality**: Unlike general-purpose OSs (e.g., Windows, Linux), embedded OSs are tailored for specific applications. They include only the necessary features and exclude unnecessary components to save resources.
    
4. **Low Power Consumption**: Embedded systems often run on batteries or have strict power constraints. The OS is optimized to minimize power usage, extending the device's operational life.
    
5. **High Reliability and Stability**: Embedded systems are often used in critical applications where failure is not an option (e.g., aerospace, medical devices). The OS must be highly reliable and stable, with minimal downtime or crashes.
    
6. **Deterministic Behavior**: The OS must provide predictable performance, especially in real-time systems, where tasks must be completed within guaranteed time limits.
    
7. **Small Footprint**: The OS occupies minimal storage space, often fitting into a small chip or microcontroller, leaving room for the application software.
    
8. **Limited User Interface**: Many embedded systems have no or minimal user interfaces (e.g., headless devices). If a UI is present, it is usually simple (e.g., buttons, LEDs, or a small display).
    
9. **Support for Hardware Abstraction**: The OS provides drivers and APIs to abstract hardware details, allowing developers to focus on application logic without dealing with low-level hardware specifics.
    
10. **Modularity**: Embedded OSs are often modular, allowing developers to include or exclude components (e.g., file systems, networking stacks) based on the application's needs.
    

---

### Two Approaches in Developing Embedded OS

1. **Monolithic Kernel Approach**
    
    - In this approach, the OS kernel is a single, large executable that includes all core functionalities (e.g., memory management, task scheduling, device drivers) in one address space.
        
    - **Advantages**:
        
        - High performance due to direct communication between components.
            
        - Simpler to design for small-scale systems.
            
    - **Disadvantages**:
        
        - Less modular, making it harder to maintain or update.
            
        - A bug in one component can crash the entire system.
            
    - **Example**: Early versions of Linux (though modern Linux is more modular).
        
2. **Microkernel Approach**
    
    - The microkernel approach minimizes the kernel's size by moving most OS services (e.g., file systems, networking) to user space as separate processes. The kernel retains only essential functions like inter-process communication (IPC) and basic scheduling.
        
    - **Advantages**:
        
        - High modularity and easier maintenance.
            
        - Improved reliability and stability (a failure in one service doesn’t crash the entire OS).
            
        - Easier to customize and extend.
            
    - **Disadvantages**:
        
        - Slightly lower performance due to IPC overhead.
            
        - More complex to design and implement.
            
    - **Example**: QNX, MINIX.
        

---

### Additional Notes:

- **Hybrid Approaches**: Some modern embedded OSs combine monolithic and microkernel features (e.g., Windows CE, some Linux distributions) to balance performance and modularity.
    
- **Customization**: Developers often customize existing embedded OSs (e.g., FreeRTOS, VxWorks) by adding or removing modules to fit specific hardware and application requirements.
    

These approaches and characteristics ensure that embedded OSs meet the stringent demands of their target applications while optimizing resource usage and performance.