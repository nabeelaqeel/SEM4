# Q1

![](../../images/Pasted%20image%2020250706223628.png)
## Question 1: Memory Allocation Scheme Drawbacks

a. **Single-user Contiguous Scheme 
- _Major drawback_: Only one process can be loaded into memory at a time, leading to poor resource utilization and inability to support multiprogramming.
    
b. **Fixed Partition 
- _Major drawback_: Internal fragmentation occurs when a process is smaller than the partition size, wasting memory space.
    
c. **Dynamic Partition 
- _Major drawback_: External fragmentation occurs over time as memory is allocated and freed in variable-sized blocks, leaving small unusable gaps between allocated blocks.
    
d. **Relocatable Dynamic Partitions 
- _Major drawback_: Requires additional overhead for compaction (memory reorganization) to reduce external fragmentation, which consumes CPU time.

# Q2

![](../../images/Pasted%20image%2020250706223646.png)

 
 a. Preemptive vs Non-preemptive Scheduling

**Preemptive Scheduling**:
- The operating system can interrupt a currently running process to allocate the CPU to another process.  
- Provides better response time for interactive systems.
- More complex to implement due to context switching overhead.
- Examples: Round Robin, SRT (Shortest Remaining Time).
    

**Non-preemptive Scheduling**:
- A process keeps the CPU until it voluntarily releases it (either completes or blocks for I/O).
- Simpler to implement but can lead to poor response times.
- Examples: FCFS (First Come First Serve), SJN (Shortest Job Next).

 b. Round Robin Time Quantum Effects

The size of the time quantum in Round Robin scheduling significantly affects system performance:

1. **Very Large Quantum**:
    - Behaves like FCFS scheduling.
    - Poor response time for interactive processes.
    - Low context switching overhead.        
2. **Very Small Quantum**:
    - Excellent response time as processes get frequent CPU access.
    - High context switching overhead which can degrade overall system performance.
    - May lead to thrashing if too much time is spent switching processes.
3. **Optimal Quantum Size**:
    - Typically between 10-100 milliseconds.
    - Balances good response time with reasonable context switching overhead.
    - Should be large enough to allow most processes to complete their CPU burst but small enough to provide good interactivity.

# Q3
![](../../images/Pasted%20image%2020250706223707.png)

![](../../images/Pasted%20image%2020250706223728.png)

Question 3: Memory Allocation

 Given:
- **Jobs**: A(256K), B(900K), C(50K), D(350K)
- **Memory Blocks**: Block1(910K), Block2(900K), Block3(200K), Block4(300K)

 a. Best-fit Allocation
Best-fit selects the smallest available block that can satisfy the request.
- **Job A (256K)**:
    - Block1: 910K (waste 654K)
    - Block2: 900K (waste 644K)
    - Block3: 200K (too small)
    - Block4: 300K (waste 44K) ← Best fit
    - _Allocated to Block4_
        
- **Job B (900K)**:
    
    - Block1: 910K (waste 10K) 
    - Block2: 900K (exact fit) ← Best fit
    - _Allocated to Block2_ (exact fit is better than Block1's 10K waste)
        
- **Job C (50K)**:
    
    - Block1: 910K(waste 860K)
    - Block2 : emaining 10K (too small)
    - Block3: 200K (waste 150K) ← Best fit
    - Block4: remaining 44K (too small)
    - _Allocated to Block3_
        
- **Job D (350K)**:
    
    - Block1: 910K(waste 560K) ← Best fit
    - Block2 : remaining 10K (too small)
    - Block3: remaining 150K (too small)
    - Block4: remaining 44K (too small)
    - _Allocated to Block1_

```
Block1: [Job D:350K/910K] (560K remaining)
Block2: [Job B:900K/900K] (0K remaining)
Block3: [Job C:50K/200K] (150K remaining)
Block4: [Job A:256K/300K] (44K remaining)
```

 b. First-fit Allocation

First-fit allocates to the first block that can satisfy the request.
- **Job A (256K)**:
    - Check Block1: 910K (fits)
    - _Allocated to Block1_
        
- **Job B (900K)**:
    - Block1: 910K-256K=654K (too small)
    - Block2: 900K (fits)
    - _Allocated to Block2_
        
- **Job C (50K)**:
    - Block1: 654K remaining (fits)
    - _Allocated to Block1_
        
- **Job D (350K)**:
    - Block1: 654K-50K=604K (fits)
    - _Allocated to Block1_

```
Block1: [Job A:256K, Job C:50K, Job D:350K] (604K-350K=254K remaining)
Block2: [Job B:900K/900K] (0K remaining)
Block3: [Empty:200K] (200K remaining)
Block4: [Empty:300K] (300K remaining)
```

c. Total Internal Fragmentation with Best-fit

Internal fragmentation is the unused memory within allocated blocks.

- Block1: 560K remaining (after Job D)    
- Block2: 0K remaining (exact fit)
- Block3: 150K remaining (after Job C)
- Block4: 44K remaining (after Job A)
    
Total internal fragmentation = 560 + 0 + 150 + 44 = **754K**

# Q4
![](../../images/Pasted%20image%2020250706223743.png)


Given:
- Job size: 715 bytes
- Page size: 126 bytes
    

Calculations:
1. Number of full pages = floor(715 / 126) = 5 pages (5 × 126 = 630 bytes)
2. Bytes on last page = 715 - 630 = 85 bytes
3. Page numbering starts at 1, so last page is page number 6.
    

Answer:
- **85 bytes** would be loaded onto the last page.
- This would be **page number 6**.

# Q5
![](../../images/Pasted%20image%2020250706223811.png)![](../../images/Pasted%20image%2020250706223824.png)
Given jobs:
- A: arrival 0, CPU 15
- B: arrival 2, CPU 2
- C: arrival 3, CPU 14
- D: arrival 6, CPU 10
- E: arrival 10, CPU 2

### a. FCFS (First Come First Serve)

**Timeline**:
```
0  - 15: A
15 - 17: B
17 - 31: C
31 - 41: D
41 - 43: E
```

**turnaround Times**:

- A: 15 - 0 = 15
- B: 17 - 2 = 15
- C: 31 - 3 = 28
- D: 41 - 6 = 35
- E: 43 - 10 = 33
    
**Average Turnaround Time**: (15 + 15 + 28 + 35 + 33)/5 = 126/5 = **25.2**

### b. SJN (Shortest Job Next)

 timeline:
```
0  - 15: A
15 - 17: B
17 - 19: E
19 - 29: D
29 - 43: C
```

**Turnaround Times**:

- A: 15 - 0 = 15
- B: 17 - 2 = 15
- E: 19 - 10 = 9
- D: 29 - 6 = 23
- C: 43 - 3 = 40
    
**Average Turnaround Time**: (15 + 15 + 9 + 23 + 40)/5 = 102/5 = **20.4**

### c. SRT (Shortest Remaining Time)

Preemptive version of SJN that considers remaining time at each decision point.

**Timeline**:

```
0 - 2 : A (remain 13)
2 - 4 : B (finish)
4 - 6 : A (remain 11)
6 - 10: D (remain 6)
10 - 12 : E (finish)
12 - 18 : D (finish)
18 - 29 : A (finish)
29 - 43 : C (finish)

```

**Turnaround Times**:
finish - start 

- A: 29 - 0 = 29
- B: 4 - 2 = 2
- E: 12 - 10 = 2
- D: 18 - 6 = 12
- C: 43 - 3 = 40

**Average Turnaround Time**: (29 + 2 + 2 + 12 + 40)/5 = 85/5 = **17**

# Q6
![](../../images/Pasted%20image%2020250706223844.png)
![](../../images/Pasted%20image%2020250706223906.png)
![](../../images/Pasted%20image%2020250706223920.png)
## Question 6: Deadlock Avoidance

Given system:
- 6 processes (P0-P5), 4 resources (R1-R4)
- Total resources: R1=15, R2=6, R3=9, R4=10


 a. Available Vector Calculation

Available = Total resources - sum of allocated resources
Calculate allocated resources:

- R1: 2+0+4+1+1+1 = 9 
- R2: 0+1+1+0+1+0 = 3
- R3: 2+1+0+0+0+1 = 4
- R4: 1+1+2+1+0+1 = 6
    

Available = Total - Allocated:

- R1: 15 - 9 = 6    
- R2: 6 - 3 = 3
- R3: 9 - 4 = 5
- R4: 10 - 6 = 4
    

**Available Vector**: (6, 3, 5, 4)

b. Need Matrix Calculation

Need = Claim - Allocation
Compute for each process:

|Process|R1 Need|R2 Need|R3 Need|R4 Need|
|---|---|---|---|---|
|P0|9-2=7|5-0=5|5-2=3|5-1=4|
|P1|2-0=2|2-1=1|3-1=2|3-1=2|
|P2|7-4=3|5-1=4|4-0=4|4-2=2|
|P3|3-1=2|3-0=3|3-0=3|2-1=1|
|P4|5-1=4|2-1=1|2-0=2|1-0=1|
|P5|4-1=3|4-0=4|4-1=3|4-1=3|

**Need Matrix**:

|Process|R1|R2|R3|R4|
|---|---|---|---|---|
|P0|7|5|3|4|
|P1|2|1|2|2|
|P2|3|4|4|2|
|P3|2|3|3|1|
|P4|4|1|2|1|
|P5|3|4|3|3|

 c. Safety Check with Given Sequence

Check if the sequence P3 → P4 → P5 → P2 → P1 → P0 is safe:
Initial Available: (6,3,5,4)

1. **P3**:
    - Need: (2,3,3,1)
    - Available ≥ Need? (6,3,5,4) ≥ (2,3,3,1)? Yes
    - New Available = (6+1,3+0,5+0,4+1) = (7,3,5,5)
2. **P4**:
    - Need: (4,1,2,1)
    - Available ≥ Need? (7,3,5,5) ≥ (4,1,2,1)? Yes
    - New Available = (7+1,3+1,5+0,5+0) = (8,4,5,5)
3. **P5**:
    - Need: (3,4,3,3)
    - Available ≥ Need? (8,4,5,5) ≥ (3,4,3,3)? Yes
    - New Available = (8+1,4+0,5+1,5+1) = (9,4,6,6)
4. **P2**:
    - Need: (3,4,4,2)
    - Available ≥ Need? (9,4,6,6) ≥ (3,4,4,2)? Yes
    - New Available = (9+4,4+1,6+0,6+2) = (13,5,6,8)
5. **P1**:
    - Need: (2,1,2,2)
    - Available ≥ Need? (13,5,6,8) ≥ (2,1,2,2)? Yes
    - New Available = (13+0,5+1,6+1,8+1) = (13,6,7,9)
6. **P0**:
    - Need: (7,5,3,4)
    - Available ≥ Need? (13,6,7,9) ≥ (7,5,3,4)? Yes
    - New Available = (13+2,6+0,7+2,9+1) = (15,6,9,10)

Since all processes can complete, the system is in a **safe state**.

 d. Resource Request from P5

Request from P5: (3,2,3,3)

Check if this request can be granted:

1. **Check if Request ≤ Need**:
    - P5's Need: (3,4,3,3)
    - Request (3,2,3,3) ≤ Need? Yes (3≤3, 2≤4, 3≤3, 3≤3)
        
2. **Check if Request ≤ Available**:
    - Available: (6,3,5,4)
    - Request (3,2,3,3) ≤ Available? Yes (3≤6, 2≤3, 3≤5, 3≤4)
        
3. **Assume request granted and check safety**:
    - New Allocation for P5: (1+3,0+2,1+3,1+3) = (4,2,4,4)
    - New Available: (6-3,3-2,5-3,4-3) = (3,1,2,1)
    - New Need for P5: (3-3,4-2,3-3,3-3) = (0,2,0,0)
        

Now check if system is still in safe state. Try to find a safe sequence:

Looking at processes:

- P1: Need (2,1,2,2) ≤ Available (3,1,2,1)? 2≤3,1≤1,2≤2,2>1 → No
- P3: Need (2,3,3,1) ≤ Available? 3>1 → No
- P4: Need (4,1,2,1) ≤ Available? 4>3 → No
- P0: Need (7,5,3,4) ≤ Available? No
- P2: Need (3,4,4,2) ≤ Available? No
- P5: Need (0,2,0,0) ≤ Available? 0≤3,2>1 → No

No process can run with the current available resources. Therefore, granting this request would lead to an **unsafe state**, so the request **should not be granted**.

**Conclusion**: The request should be denied as it would lead the system to an unsafe state where deadlock could occur.