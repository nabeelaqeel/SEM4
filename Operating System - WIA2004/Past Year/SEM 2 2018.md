# Q1
![](../../images/Pasted%20image%2020250707010638.png)
## Question 1: Major Drawbacks of Memory Allocation Schemes

### a) Single-user Contiguous Scheme

**Major drawback:** Only one process can be in memory at a time, leading to extremely poor resource utilization. The entire memory is allocated to a single process regardless of its actual memory requirements, resulting in significant wasted memory when the process doesn't need all available memory.

### b) Fixed Partition

**Major drawback:** Internal fragmentation occurs because each partition is of fixed size. If a process requires less memory than the partition size, the remaining memory in that partition cannot be used by other processes. This leads to inefficient memory utilization.

### c) Dynamic Partition

**Major drawback:** External fragmentation occurs over time as memory is allocated and freed. Small gaps between allocated partitions become too small to be useful for new processes, even though the total free memory might be sufficient if it were contiguous.

### d) Relocatable Dynamic Partitions

**Major drawback:** Requires additional overhead for compaction (periodically moving processes to eliminate fragmentation). This compaction process consumes CPU time and can impact system performance during the relocation process.
# Q2
![](../../images/Pasted%20image%2020250707010647.png)
## Question 2: Role of Bounds Register and Relocation Register

### Bounds Register

The bounds register contains the highest physical memory address that a process can access. It is used for memory protection by ensuring that a process cannot access memory outside its allocated space. When a process generates a logical address, the operating system checks if it exceeds the bounds register value before allowing the access.

### Relocation Register

The relocation register contains the base address (starting address) of a process in physical memory. It is used to translate logical addresses to physical addresses by adding the logical address to the value in the relocation register. This allows processes to be loaded anywhere in physical memory while maintaining correct address references.

Together, these registers enable memory protection and address translation in a partitioned memory system.
# Q3
![](../../images/Pasted%20image%2020250707010703.png)
![](../../images/Pasted%20image%2020250707010718.png)


## Question 3: Memory Allocation Algorithms

### Given:

Memory Block List (assuming sizes are provided but not shown in the question - typical blocks might be 300K, 400K, 200K, 500K, 100K for this type of question)  
Job List:

- Job A: 256K
    
- Job B: 900K
    
- Job C: 50K
    
- Job D: 350K
    

_(Note: Since the actual memory block sizes aren't provided in the question, I'll assume some reasonable block sizes for demonstration purposes. In a real exam, these would be given.)_

Assumed Memory Blocks:

1. Block 1: 300K
    
2. Block 2: 400K
    
3. Block 3: 200K
    
4. Block 4: 500K
    
5. Block 5: 100K
    

### a) Best-fit Allocation

Best-fit searches for the smallest available block that can satisfy the request.

- Job A (256K):
    
    - Possible blocks: Block 1 (300K), Block 2 (400K), Block 4 (500K)
        
    - Best fit: Block 1 (300K) - smallest sufficient block
        
    - Remaining: 300K - 256K = 44K
        
- Job B (900K):
    
    - No single block can satisfy this request (largest block is 500K)
        
    - Cannot be allocated
        
- Job C (50K):
    
    - Possible blocks: Block 3 (200K), Block 5 (100K), Block 1's remaining 44K
        
    - Best fit: Block 5 (100K)
        
    - Remaining: 100K - 50K = 50K
        
- Job D (350K):
    
    - Possible blocks: Block 2 (400K), Block 4 (500K)
        
    - Best fit: Block 2 (400K)
        
    - Remaining: 400K - 350K = 50K
        

### b) First-fit Allocation

First-fit allocates the first sufficient block found.

- Job A (256K):
    
    - First sufficient block: Block 1 (300K)
        
    - Remaining: 44K
        
- Job B (900K):
    
    - No single block can satisfy
        
    - Cannot be allocated
        
- Job C (50K):
    
    - First sufficient block: Block 1's remaining 44K (too small)
        
    - Next: Block 2 (400K)
        
    - Allocated to Block 2
        
    - Remaining: 400K - 50K = 350K
        
- Job D (350K):
    
    - First sufficient block: Block 4 (500K)
        
    - Remaining: 500K - 350K = 150K
        

### c) Total Internal Fragmentation with Best-fit

Internal fragmentation occurs when allocated memory is larger than requested.

- Job A: 44K (300K - 256K)
    
- Job C: 50K (100K - 50K)
    
- Job D: 50K (400K - 350K)
    
- Job B: Not allocated (no fragmentation)
    
- Unallocated blocks: Block 3 (200K), Block 4 (500K - unused in best-fit)
    

Total internal fragmentation = 44K + 50K + 50K = 144K
# Q4
![](../../images/Pasted%20image%2020250707010736.png)
## Question 4: Paging Calculation

Given:

- Job size: 715 bytes
    
- Page size: 126 bytes
    

Calculations:

1. Number of full pages = floor(715 / 126) = 5 pages (5 × 126 = 630 bytes)
    
2. Bytes remaining = 715 - 630 = 85 bytes
    
3. These 85 bytes go into a 6th page
    
4. The last page (page 6) contains 85 bytes
    

Answer:

- Bytes in last page: 85 bytes
    
- Page number: 6
# Q5 
![](../../images/Pasted%20image%2020250707010744.png)
![](../../images/Pasted%20image%2020250707010754.png)
## Question 5: Scheduling Algorithms

Given jobs:

|Job|Arrival|CPU Cycle|
|---|---|---|
|A|0|15|
|B|2|2|
|C|3|14|
|D|6|10|
|E|10|2|

### a) FCFS (First-Come, First-Served)

Timeline:  
0-15: A  
15-17: B  
17-31: C  
31-41: D  
41-43: E

Turnaround times:

- A: 15 - 0 = 15
    
- B: 17 - 2 = 15
    
- C: 31 - 3 = 28
    
- D: 41 - 6 = 35
    
- E: 43 - 10 = 33
    

Average turnaround = (15 + 15 + 28 + 35 + 33)/5 = 126/5 = 25.2

### b) SJN (Shortest Job Next)

At time 0: Only A available → run A  
At time 2: B arrives (2), A has 13 left  
B is shorter than A's remaining → preempt A, run B (2-4)  
At time 4: A has 13, C arrives at 3 (14), E arrives at 10 (2), D arrives at 6 (10)  
E not arrived yet, shortest is A (13) → run A (4-17)  
At time 6: D arrives (10)  
At time 10: E arrives (2) → shortest available  
Preempt A (has 7 left), run E (10-12)  
At time 12: available jobs - A (7), C (14), D (10)  
Shortest is A → run A (12-19)  
At time 19: available - C (14), D (10)  
Run D (19-29)  
At time 29: run C (29-43)

Timeline:  
0-2: A  
2-4: B  
4-10: A  
10-12: E  
12-19: A  
19-29: D  
29-43: C

Turnaround times:

- A: 19 - 0 = 19
    
- B: 4 - 2 = 2
    
- C: 43 - 3 = 40
    
- D: 29 - 6 = 23
    
- E: 12 - 10 = 2
    

Average turnaround = (19 + 2 + 40 + 23 + 2)/5 = 86/5 = 17.2

### c) SRT (Shortest Remaining Time)

Similar to SJN but with preemption when shorter jobs arrive.

Timeline:  
0-2: A (remaining: 13)  
2-3: B (remaining: 1) [B is shorter than A's 13]  
3-4: B completes  
4-6: A (remaining: 11)  
6-10: A (remaining: 7) [D arrives at 6 (10) - longer than A's 11→7]  
10-12: E (2) [shorter than A's 7]  
12-19: A (7)  
19-29: D (10) [C has 14 remaining]  
29-43: C (14)

Turnaround times:

- A: 19 - 0 = 19
    
- B: 4 - 2 = 2
    
- C: 43 - 3 = 40
    
- D: 29 - 6 = 23
    
- E: 12 - 10 = 2
    

Average turnaround = (19 + 2 + 40 + 23 + 2)/5 = 86/5 = 17.2

_(Note: For this particular set of jobs, SJN and SRT give the same result, but this isn't always the case.)_
# Q6
![](../../images/Pasted%20image%2020250707010809.png)
## Question 6: Terminology Differences

### a) Buffering vs Blocking

**Buffering** is the process of temporarily storing data in memory (a buffer) to compensate for differences in speed between devices or processes that produce and consume data. It smooths out data flow and prevents bottlenecks.

**Blocking** refers to organizing data into fixed-size blocks for storage or transmission. It's a method of data organization where each block is treated as a unit for I/O operations, often used in disk storage and network transmission.

Key difference: Buffering is about temporary storage for speed matching, while blocking is about structuring data into fixed-size units.

### b) Seek Time vs Search Time

**Seek Time** is the time required for a disk's read/write head to move to the correct track on the disk surface. It's a mechanical movement time specific to storage devices with moving parts.

**Search Time** (or rotational latency) is the additional time needed for the desired sector to rotate under the head once the correct track is found. It depends on disk rotation speed.

Key difference: Seek time is about head movement between tracks, while search time is about waiting for the disk to rotate to the right position.
# Q7
![](../../images/Pasted%20image%2020250707010822.png)
## Question 7: File Access Permissions

The notation appears to be using R (Read), W (Write), E (Execute), D (Delete) with hyphens indicating denied permissions.

### a) File_1 R–ED

- Allowed: Read (R)
    
- Denied: Write (-), Execute (E), Delete (D)
    
- User can only read the file, cannot modify, execute, or delete it.
    

### b) File_12 RWE–

- Allowed: Read (R), Write (W), Execute (E)
    
- Denied: Delete (-)
    
- User can read, modify, and execute the file, but cannot delete it.
    

### c) File_13 RW–D

- Allowed: Read (R), Write (W), Delete (D)
    
- Denied: Execute (-)
    
- User can read, modify, and delete the file, but cannot execute it.
    

### d) File_14 --E–

- Allowed: Execute (E)
    
- Denied: Read (-), Write (-), Delete (-)
    
- User can only execute the file (likely a program), cannot view its contents or modify it.
# Q8
![](../../images/Pasted%20image%2020250707010837.png) 

Question 8: Term Definitions

### a) Process

A process is an instance of a computer program that is being executed. It contains the program code and its current activity, including the program counter, processor registers, memory allocation, and other operating system resources. Processes are isolated from each other and communicate through inter-process communication mechanisms.

### b) Deadlock

A deadlock is a situation in a multi-process system where two or more processes are unable to proceed because each is waiting for the other to release a resource. Four necessary conditions must hold for deadlock: mutual exclusion, hold and wait, no preemption, and circular wait.

### c) Thread

A thread is a lightweight unit of execution within a process. A single process can contain multiple threads that share the process's resources (memory, files) but can execute independently. Threads enable parallel execution within the same program, improving performance and responsiveness.

### d) Semaphore

A semaphore is a synchronization variable used to control access to a common resource by multiple processes/threads in a concurrent system. It maintains a count and provides two atomic operations: wait (which decrements the count and may block) and signal (which increments the count and may wake a waiting process). Semaphores are used to solve critical section problems and implement synchronization between processes.